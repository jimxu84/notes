以下是您提供内容的专业中文翻译：

---

B树索引
==============

本目录实现了Lehman和Yao的高并发B树管理算法（P. Lehman和S. Yao，《Efficient Locking for Concurrent Operations on B-Trees》，ACM Transactions on Database Systems，第6卷第4期，1981年12月，第650-670页）。同时采用了Lanin和Shasha论文中描述的简化版删除逻辑（V. Lanin和D. Shasha，《A Symmetric Concurrent B-Tree Algorithm》，1986年秋季联合计算机会议论文集，第380-389页）。

基础Lehman & Yao算法
--------------------------------
相比经典B树，L&Y算法在每页添加了指向右兄弟节点的右向指针，以及"高键"——表示该页允许存储的键值上界。这两个新增特性使得系统能检测并发页分裂，从而实现无需读锁的树搜索（仅需防止单页在读取时被修改）。

搜索算法沿下行链接到达子页时，会对比页面的高键与搜索键。若搜索键大于高键，则说明该页已并发分裂，需通过右向指针定位到新的键范围所在页。若页面多次分裂，此过程可能需重复执行。

L&Y将内部页的"分隔键"与下行链接交替存储，而非元组形式。我们使用"枢轴元组"专指仅用于树导航的非堆元组。所有非叶页元组和叶页高键均属枢轴元组。由于枢轴元组仅表征键空间分布，其属性值可复制自早已被VACUUM清除的非枢轴元组。枢轴元组可能包含"分隔键+下行链接"、仅分隔键（下行链接隐式未定义）或仅下行链接（所有属性被截断）。

通过将堆TID作为决胜属性，确保所有B树键唯一。逻辑重复项按堆TID排序存储。这是必要的，因为L&Y要求子树S的键范围满足Ki < v ≤ Ki+1（Ki必须严格小于v，键唯一性保证此条件）。除叶页高键可能与末项完全相等外，同级键始终保持唯一。

Postgres的后缀截断实现必须维护L&Y不变式，并用"负无穷"标记枢轴元组中截断的属性。若对L&Y不变式与实际应用的关联存疑，后续后缀截断章节将提供详解。

与Lehman & Yao算法的差异
-----------------------------------------
为适配Postgres，我们进行了以下调整：

1. **读锁机制**：L&Y假设内存页副本不共享，而Postgres在后台进程间共享缓冲区。为此我们对B树页实施页级读锁，确保检查记录时不被修改，虽降低并发但保证正确性。

2. **双向扫描支持**：正向扫描直接使用L&Y要求的右兄弟指针（只需定位到起始点后仅访问叶页）。为支持反向扫描，额外添加类似右向指针的"左兄弟"链接。这给分裂算法增加步骤：分裂时需同时锁定原右兄弟页更新其左向链接（由于该页写锁持有者不会对我们的页请求写锁，此操作安全）。反向扫描还需处理左兄弟页可能分裂的情况：需右移直至找到右向链接匹配原页的活页。

3. **锁持有优化**：页读锁仅在扫描检查页时持有。为减少锁操作，索引扫描会一次性复制叶页所有匹配项的堆TID到本地存储，随后在无索引锁状态下处理。某些情况下持续pin叶页以防止并发删除（此时扫描实质上暂停在页间）。由于项不会跨越既有页边界，此设计可安全应对并发插入和页分裂。

4. **根页分裂**：L&Y未讨论根页满分裂场景。我们的解决方案是像普通页一样分裂根页，然后构建包含两个结果页指针的新根页（二者成为树下一级的兄弟），最后通过元数据页更新根指针。因根页无特殊处理，即使搜索在元数据更新前读取，仍可通过右向指针定位迁移数据。

5. **树高度增长处理**：当插入者递归向上分裂内部页时，可能需访问超过初始根层级的页（原下降栈无法定位）。此时通过重新下降树直至目标层级上方，再右移定位。通过页存储的层级号可识别正确层级，此场景罕见故无需优化方案。

6. **锁耦合简化**：L&Y在树上升重定位子页下行链接时需同时持有三把锁（子页、原父页及其右兄弟）。我们通过块号匹配父页枢轴元组的下行链接，无需同级页锁耦合。Lanin和Shasha虽也不耦合同级锁，但其乐观算法可能重试。我们保留L&Y保守的父子锁耦合方案以保持简单性。

7. **变长键支持**：L&Y假设定长键，而我们需处理变长键。因此每页键数量不固定，仅存满为止。分裂时尽量均衡字节数（考虑后缀截断），且必须包含待插入项以免其无法放入目标页。

VACUUM期间的索引元组删除
-----------------------------------
删除叶项前需获取目标页的完全清理锁，确保无其他后台进程pin该页。此非B树正确性必需，而是为防止VACUUM与未准备处理并发TID回收的索引扫描冲突。仅VACUUM能标记堆中LP_UNUSED项（在btbulkdelete返回后发生），索引扫描保持pin至堆访问结束可阻止并发TID回收。

此方法较粗糙，故尽可能避免。实践中多数扫描不持续pin，需直接处理TID回收（更复杂且非总可行）。见后文并发TID回收安全化章节。

机会性索引元组删除在仅持排他锁时执行类似页级修改。因后续无TID回收问题（仅VACUUM可使TID可回收）。另见简单删除与自底向上删除章节。

由于pin不总保持且分裂可能发生在pin期间，索引扫描可能返回已不在pin页而位于其右侧的项。为确保VACUUM不提前回收此类TID，要求btbulkdelete获取索引所有叶页的清理锁（即使无删除项）。此操作无需特定顺序。

VACUUM线性扫描与并发页分裂
--------------------------------------------
VACUUM通过物理块序线性扫描寻找可删除TID，同时考虑删除空页。难点在于避免并发页分裂导致遗漏：分裂可能将未扫描页的元组移至已扫描的低编号页。

通过"vacuum cycle ID"机制判断页是否在btbulkdelete周期开始后分裂。若发现分裂且右链指向低编号页，则暂停顺序扫描转至该页，沿右链清理死元组直至遇到未分裂页或超过外部扫描位置。此设计确保访问所有元组（可能重复访问，仅影响统计准确性）。即使检测存在小概率假阳性（只要无假阴性），仍可通过页存储的小计数器实现。

VACUUM期间整页删除
-----------------------------------
仅当页完全空时才考虑删除（合并部分满页虽提高空间利用率，但因需左右移动数据项可能干扰反向扫描）。另规定永不删除层级最右页（简化遍历算法）。页删除始终从空叶页开始，内部页仅作为子树删除的一部分（子树为"瘦长"结构：单列内部页链加单叶页，每层级一页覆盖相同键空间）。

叶页删除分两阶段：
1. **第一阶段**：通过类似插入分裂的搜索定位父页，锁定目标页和父页，将目标页的下行链接改为指向右兄弟并移除原链接，标记目标页为半死状态（半死页将被后续搜索忽略）。
2. **第二阶段**：按顺序锁定目标页的左兄弟（如有）、自身及右兄弟，更新兄弟侧链并标记目标页为已删除。

删除父页最后子页时更复杂：第一阶段保留叶页直接父页，转而移除祖父母页对父页的下行链接。若无其他子页则递归向上直至找到多子父页。半死叶页存储被移除下行链接的页块号，形成无下行链接指向的链式内部页结构。

递归期间保持叶页锁（中间页无需锁），因上层插入仅由子页分裂引发（叶页锁阻止分裂）。半死标记确保链中内部页不会新增子页。

删除子树顶部下行链接将键空间原子转移至右兄弟。并发搜索可能访问中间页，但到达叶层半死页时会右移（半死页的右兄弟必为"表亲页"而非"真兄弟页"）。

第二阶段逐步解除链中页的兄弟链接：先解链顶部页，半死叶页指向链中下一页，循环至无内部页剩余，最后解链半死叶页。

已删除页不能立即回收，因可能有进程正引用（如刚离开父页的搜索或兄弟页扫描）。这些进程需能观测已删除页以通过右移恢复（类似处理并发分裂）。搜索者无需担心并发页回收。

见后文"将删除页放入FSM"章节了解VACUUM安全回收的时机与方法。

页删除与反向扫描
---------------------------------
反向左移需考虑左兄弟刚分裂（需找到左兄弟派生的最右页）及原页可能被删除（不再存在于兄弟链）的情况。左移算法如下：

1. 记当前页为"原页"
2. 跟随原页左链（若为0则结束）
3. 若当前页存活且右链匹配原页，则结束
4. 否则右移寻找右链匹配原页的活页（理论上可扫描至索引右端，但实践中数次尝试后放弃更优——原页兄弟分裂多次概率极低，未找到匹配链多半原页已删除）
5. 返回原页：若仍存活则用其当前左链重启步骤1；若已死则右移至非死页（最右页永不被删），标记为新原页后重启

此算法正确性在于：步骤4找到的活页与原页左键空间边界相同，最终退出时必位于右键空间边界匹配原页左边界的页，确保不遗漏或重复扫描。

页删除与树高
-----------------------------
因永不删除层级最右页（特别是根页），树高不会降低。大量删除后可能出现"瘦高"树（根下多级单页）。虽操作仍正确，但徒增下降层级耗时。借鉴Lanin和Shasha的"fast root"方案：跟踪最低单页层级，元数据页同时存储真根和fast root指针。常规操作从fast root启动搜索。

当分裂单页层级或删除层级倒数第二页时（易检测），需调整fast root指针。分裂时作为父层级插入的原子更新部分；删除时作为删除原子更新部分（元数据页最后加锁避免死锁）。防止并发操作竞争。

将删除页放入FSM
--------------------------------
页回收与删除解耦。仅当无扫描可能引用删除页时，方可将其放入空闲空间映射（FSM）回收。在此之前，删除页需保持兄弟链接不变，作为墓碑供并发搜索检测并恢复（类似处理并发分裂）。此设计实现了Lanin和Shasha所称的"排水技术"。

具体通过等待所有活跃快照及删除时的注册快照消失实现（虽过度严格但易于实现）。完全删除的页标记下一个事务计数器值，当存储XID对所有人可见时VACUUM可回收。作为副作用，需等待无快照的运行XID提交。

PostgreSQL 14前，VACUUM仅在线性扫描中回收旧删除页（前次VACUUM操作所删）。新删除页永不放入FSM（假设总不安全）。此假设过于悲观——实践中新删除页常很快可安全回收。虽无理论方法预测回收安全性（可能立即安全或下次VACUUM仍不安全），但回收安全本质是物理数据结构一致性问题，与VACUUM后端状态无关。

PostgreSQL 14新增能力：VACUUM在删除页的完整索引扫描结束时评估是否可回收新删除页。此时检查较便利，仅需保留少量新删除页簿记信息（内存状态避免二次访问）。使用本地簿记的safexid值延迟判断回收安全性。

删除页后需额外FSM间接层，源于L&Y设计中对索引扫描的高度宽容规则。通常索引扫描下降时不持有任何锁或pin（不保持"层级间"交叉锁），但绝不允许因并发回收（非删除）跳转至无关页，否则导致查询错误。更简单的页删除方案若不需延迟回收，则无法兼容L&Y设计。

将已删除页放入FSM待回收不立即改变页状态，实际回收时才覆写内容（分裂操作将删除页转为新右兄弟页）。

实现并发TID回收安全
------------------------------------
如前述VACUUM删除索引元组章节所述，我们通过锁协议让单个索引扫描避免并发TID回收。但扫描在安全时会主动释放叶页pin（减少阻塞VACUUM）。对游标索引扫描尤为重要——空闲游标可能长期停滞，长时间阻塞VACUUM将导致灾难。

不持pin的扫描通过保持MVCC快照保护，虽防止错误查询结果，但无法阻止TID回收本身（仅持pin访问堆可确保）。

仅索引扫描绝不能释放pin，因其无法容忍引用TID被回收。仅索引扫描通常仅访问可见性映射（非堆本身），若VACUUM并发将引用TID标记为LP_UNUSED，可能无法可靠察觉。随后VACUUM可能立即将整个堆页设为全可见。MVCC快照仅对普通索引扫描足够，因其需从堆获取细粒度可见性信息（能识别LP_UNUSED项为"不可见"，即使堆页全可见）。

kill_prior_tuple优化的LP_DEAD标记对释放pin的扫描更复杂：必须避免因并发TID回收导致新元组（恰与原死亡元组同TID）被错误标记。通过保守处理——若叶页LSN改变则不设任何LP_DEAD位（未记录索引不适用此优化）。

索引插入快速路径
----------------------------
针对索引键值递增插入的常见场景，我们缓存上次插入的最右叶页。下次插入时可快速检查缓存页是否仍为最右叶页及正确插入位置，避免树下降开销。

此优化基于"仅存在一个不可忽略的最右叶页"假设，故无需显式互锁。即使页被删除回收，只要未检测到缓存失效，仅当该块再次成为最右叶页时可能复用。

简单删除
---------------
若进程发现堆元组可删除（对所有事务不可见），则可标记对应索引项为"已知死亡"（LP_DEAD），后续扫描跳过该堆元组。目前仅普通索引扫描（非位图扫描）应用此优化，因其同步访问堆与索引。唯一索引冲突检查时也常设LP_DEAD位（此时持叶页排他锁更简单）。

LP_DEAD标记项可立即物理删除（因扫描仅暂停在页间，不会丢失位置）。分离步骤因LP_DEAD设置仅需共享锁（类似堆元组提示位），而物理删除需排他锁。还需为删除操作的WAL记录生成snapshotConflictHorizon（备机重做时可能引发冲突）。

延迟批处理删除启进一步优化：机会性检查邻近非LP_DEAD项（当表am访问其块生成snapshotConflictHorizon时代价极低）。任何可安全删除项将被移除。简单删除视这些项初始即被LP_DEAD标记。

去重虽可防页分裂，但我们优先选择索引元组删除。注意： posting list元组仅当所有表TID均死亡时才可设LP_DEAD位。实践中不重要，因LP_DEAD位仅是删除起点，关键在于相关TID组的粒度删除发生在页分裂前。

自底向上删除
------------------
当怀疑页重复项由连续UPDATE版本堆积导致时，尝试删除现有重复项。仅当执行器提示（如heapam的HOT优化未生效）——入队元组为逻辑未变的MVCC所需重复项时触发（此情况下可能是叶页主导写入源）。唯一索引中持续INSERT/DELETE变动也易触发（无需外部提示）。

当简单删除未能阻止分裂时触发（常因页无LP_DEAD标记）。两种机制实现紧密相关：使用相同WAL记录和表am基础设施判断可删TID/元组，仅区别在TID选取方式及表am是否提前放弃（自底向上删除接受不确定性，保持低失败成本）。

自底向上删除纯启发式驱动（简单删除保证至少删除LP_DEAD标记项）。可能找不到任何可删项，故需与表am协作平衡成本收益（详见access/tableam.h）。

自底向上删除可视为防版本驱动分裂的后备机制，借鉴分代垃圾回收的"代际假说"——多数对象早亡。nbtree中新元组常快速出现又快速失效。某些负载下垃圾高度集中在少数叶页（PostgreSQL 14前尤甚）。详见doc/src/sgml/btree.sgml中设计原则。

虽启发式简单，但能有效处理极端版本堆积。病理级版本堆积才导致分裂。我们无需理解负载，仅需识别目标病理特征——当真正病理时易察觉，受影响叶页较均匀。

WAL考量
------------------
插入删除算法本身不保证崩溃后B树一致性，依赖WAL重放实现健壮性。单个WAL条目实质是原子操作——若未完成可从日志重做。

普通项插入（非分裂）仅影响单页，故为单一WAL条目。叶项删除（若使页空则候选删除）同理。

导致页分裂的插入记录为两级WAL条目：分裂层级变更（含右兄弟左链更新）和父层级插入（可能递归向上分裂）。根分裂的后续条目为"新根"而非"插入"，细节类似。

因分裂含多原子操作，可能在分裂页与插入父页下行链接间崩溃。恢复后新页下行链接缺失，搜索算法仍正确（通过左兄弟右链找到新页），但大量缺失将影响性能。更严重的是：若缺失下行链接的页再次分裂，插入算法将无法定位父层级插入位置。

我们的解决方案是在插入搜索时动态创建缺失下行链接。虽搜索时也可执行，但最好不混入读操作更新（热备模式下不可更新）。VACUUM中处理似更自然，但因插入下行链接可能需要分裂页，磁盘不足时将失败（VACUUM可能正因磁盘不足运行，陷入死循环）。而插入本身可能需扩展物理文件。例外：VACUUM删除子页时完成中断的内部页分裂，复用分裂和删除的父项定位代码。

为识别缺失下行链接，分裂时左页标记INCOMPLETE_SPLIT。父页插入下行链接时原子清除标记。子页锁保持至父页插入完成标记清除，之后可释放（若父页也需分裂则递归前释放）。确保正常情况下不出现未完成分裂页（仅父页插入失败时可见）。恢复期间读者也可能观测到未完成分裂标记页（见后文"恢复期间扫描"）。

标记左页（虽右页缺失下行链接）因从左页右链至右页时即知需插入父页下行链接。

分裂非根单页层级时，"fast root"链接更新作为父层级插入的一部分记录。分裂根页时元数据页更新作为"新根"动作部分。

页删除每步记录为独立WAL条目：标记叶页半死并移除下行链接为一条，解链页为第二条。若VACUUM中断或系统崩溃，树仍保持搜索/插入一致性。下次VACUUM将发现半死叶页继续删除。

9.4前，恢复期间跟踪未完成分裂和页删除并在恢复结束时立即完成，而非延迟至下次插入或VACUUM。这使恢复更复杂且仅修复崩溃恢复场景。内存或磁盘不足等可恢复错误也可能导致未完成分裂。

恢复期间扫描
---------------------
nbtree索引支持热备模式读查询。每个原子操作/WAL条目独立变更，保持读者视角一致性。读者按主库相同规则锁页（可能需右移恢复"并发"分裂或删除）。

但恢复期间页锁与主库原始写操作有两点差异：
1. **分裂重放**：主库上父页与子页写锁耦合，而恢复独立处理分裂两阶段（因读者不关心未完成分裂标记。主库持额外写锁仅防其他写者观测标记，恢复无并发写者无需此保护）
2. **删除重放**：恢复不全程持有目标叶页写锁（仅主库需阻塞并发写入）

但恢复期间同级锁获取方式与原始执行一致，防止读者观测同级不一致。虽更宽松可能仍可行（多数读者可右移恢复），但我们选择保守。

恢复期间所有索引扫描以ignore_killed_tuples=false启动且永不设kill_prior_tuple。因备库最老xmin可能旧于主库，导致元组在主库不可见时备库仍可见。虽不WAL记录LP_DEAD位，但全页写入可能使其出现在备库，故必须忽略且无需设置。（主库LP_DEAD标记元组最终删除时会WAL记录，备库查询仍能获益）

注意：此指恢复期间启动的扫描。我们允许扫描在恢复期间启动并在恢复完成后正常结束，此能力对应用持续运行至关重要。

非MVCC扫描避免返回错误结果的交叉锁在备节点非必需。恢复期间回放VACUUM记录时仍获取完全清理锁，但仅锁定含删除项的叶页——足够避免中断仅索引扫描（见前文TID回收安全化）。仅需关注普通索引扫描。（XXX：未完全明确为何恢复期间完全无需此机制）

MVCC快照普通索引扫描始终安全（与原始执行相同原因）。HeapTupleSatisfiesToast()不使用MVCC语义（因非必需——若主堆行可见则toast行必可见）。只要跟随可见元组的toast指针，就无需重新检查MVCC。

其他要点
-----------------------------------
每棵B树的第0页为元数据页，存储真根和当前有效根（"fast"根）位置。为避免每次搜索获取元数据页，在索引relcache条目（rd_amcache）中缓存副本。需谨慎处理缓存指针可能过时的情况——后台进程通过检查is-root标志（访问真根时）或无兄弟页（访问fast根时）验证。最坏情况因缓存fast根指针高于真实fast根导致多下降几级，但此情况不常发生且relcache刷新会很快丢弃缓存。

算法假设每页至少容纳三项（一高键两真实数据项），故不接受超过1/3页大小的项。更大项虽可能临时工作，但取决于页内容可能后续失败。

本代码中ScanKey以两种根本不同方式使用：
1. **搜索扫描键**：外部调用（如btbeginscan()）传入的比较函数返回布尔值（如int4lt）。每索引列可能有多条目或无条目（键需按索引列序，但同列多键顺序未指定）。
2. **插入扫描键**（BTScanInsert结构）：使用类似ScanKey数组，但比较函数指向B树三态比较器（返回<0/=0/>0）。每索引列至多一条目，还包含扫描起始定位规则（如是否"nextkey"扫描）。插入扫描键由B树代码构建（如_bt_mkscankey()），用于定位扫描起点及新元组插入位置。（注：从搜索扫描键或截断枢轴元组构建的插入扫描键可能少于索引列数，表示剩余列无约束。）

定位扫描起点后，原始搜索扫描键逐项检查决定返回与终止（见_bt_checkkeys()）。

后缀截断说明
-----------------------------
叶页分裂时截去高键不需要的后缀键属性。保留属性须区分分裂后左右页的首末项。元组逻辑保留截断属性（隐式值为"负无穷"且无存储开销）。因高键后续复用为父页新右页的下行链接，后缀截断使枢轴元组变短。INCLUDE索引的非键属性在叶页分裂时必被截断，键属性按常规截断——非键属性对B树搜索仅是载荷。

键属性后缀截断通过提高索引扇出改善性能。技术首见于Bayer和Unterauer论文（《Prefix B-Trees》，1977年3月）。Postgres实现参考该论文，但仅实现简单前缀B树。论文假设键为维护"前缀属性"的单字符串（类似后缀树，早期字节比较总比后期重要）。Postgres当前仅支持全属性粒度截断，但可扩展opclass支持变长类型（如text）生成最小分隔键值。

叶页分裂点选择标准复杂，核心是在空间均衡与截断效果间权衡。分裂点可视作待分裂页项间的选择（假设待插入项已暂存页上）。选择最早非等值属性出现位置能最大化截断效果。虽空间均衡是首要考量，但微小调整可显著提升截断效率。

后缀截断主要价值在于缩小枢轴元组延迟内部分裂，但非唯一原因。即使对齐限制使枢轴元组未缩小，仍能避免过度限制键空间分布。

内部分裂虽无法正确后缀截断，但分裂点选择仍有价值——在填充因子最优范围内选择最小下行链接插入父页。此思想同样源自前缀B树论文，与叶层促进截断的过程类似。综合效果是后缀截断倾向产生更小、更精确的枢轴元组（尤其索引早期），而内部分裂偏置使更小的早期枢轴元组最终位于根页，延迟根分裂。

逻辑重复项需特殊处理：分裂点选择算法竭力避免跨页重复项，几乎总能选择用户键 distinct 的元组分界点（必要时接受极端不平衡分裂）。当满页重复项必须分裂时，默认假设重复项按堆TID升序插入——分裂使左页近满右页近空。此设计优雅适应大批重复项插入，最大化空间利用率。将重复项"捕获"在同叶页也使去重更高效——可低频执行且避免频繁合并posting list元组。

去重说明
-------------------------
非唯一索引中对非枢轴元组去重以减少存储并延迟（或避免）页分裂。注意唯一索引的去重目标不同（见后文）。去重在保持索引逻辑内容不变且不增加读查询开销下改变元组物理表示，将非枢轴元组合并为含堆TID数组（标准项指针格式）的单一物理元组。

去重始终惰性执行——仅在需分裂页时作为最后防线（可能先尝试自底向上删除作为次后防线）。去重仅当LP_DEAD项移除后执行，可设posting list元组的LP_DEAD位（仅当所有TID均死亡时）。

惰性去重使页分裂空间计算几乎无需posting list特例。posting list可视为后缀截断会可靠移除的额外载荷（类似INCLUDE索引的非键列）。新元组通常视为非重叠普通项（但见后文posting list分裂处理）。

posting list表示几乎与GIN相同，可轻松应用GIN的varbyte编码压缩方案。但压缩会破坏posting list分裂的空间计算假设（见后文），且nbtree为高并发读写优化，压缩收益不显著。此外压缩会使posting list子集删除变慢且复杂，不利于依赖自底向上删除的工作负载。

惰性去重主要目标在于限制随机更新的性能影响。即使相同键值的并发追加插入，其索引元组顺序也未必完全匹配堆TID顺序。延迟去重最小化页碎片。

唯一索引中的去重
-------------------------------
唯一索引的叶页能存储的distinct值数量通常固定。例如，序列列主键的叶页分裂多由最右叶页新逻辑行插入引发。若非最右叶页分裂，必由现有逻辑行UPDATE引发。仅为存储多版本分裂页是种浪费——实为永久劣化索引结构以吸收临时重复项爆发。

唯一索引去重旨在预防此类病态分裂，目标非高效存储重复项（长期看终将无重复），而是为垃圾回收争取时间避免分裂。

唯一索引叶页仅当插入（可能需分裂）过程中发现现有重复项时才去重。此基于"所有新插入均为UPDATE重复项"的假设。可能错失延迟分裂机会，但我们的终极目标是无限延迟（即完全避免）叶页分裂。对可能不可避免的分裂尝试延迟意义不大，故避免无重复唯一索引的去重开销。

注：防版本驱动分裂也是PostgreSQL 14引入的自底向上删除的目标（各类索引均适用，尤唯一索引）。自底向上删除现为优选方案，但去重有时可补充之。当删除因旧快照无法清理时，去重提供额外容量。通过去重延迟分裂可能让未来同一页的自底向上删除成功。

posting list分裂
-----------------------------
当新元组与现有posting list重叠时，执行posting list分裂。类似页分裂，posting list分裂解决新项"放不下"问题，同时原子插入新项（可能伴随页分裂）。虽不太常见，但几乎满页的新项插入若重叠posting list，将导致posting list分裂与页分裂。此时posting list分裂作为同一原子操作部分插入新项，避免并发插入同一posting list的问题，并最小化额外WAL（无需显式记录原posting list元组）。

虽与插入（或页分裂）共享原子操作，posting list分裂可视为独立附加动作。其概念上将重叠插入"重写"为在posting list右侧插入新项。posting list大小不变，故页空间计算无需特殊处理——此设计关键优势，因页分裂点选择逻辑已极复杂。

仅需少量额外步骤维持"新项从未重叠"假象：
1. 新元组堆TID替换为原posting list最右TID
2. 原新项TID重定位至posting list合适位置（通常移位腾出空间）
3. 伴随页分裂时，基于想象版本（含新项及分裂后posting元组）生成新高键

此方案避免设计"急切"原子分裂操作（不完成插入仅分裂posting list）。虽后者看似简洁，但会引发页空间计算问题——可能无足够空间分裂posting list使新项不重叠任一半，导致实际插入前操作失败。最终仍需处理需页分裂的posting list分裂，且支持可变分裂点未必提升空间利用率。

数据表示说明
-------------------------------
L&Y要求的右兄弟链保存在页"opaque data"区，左兄弟链、页层级及标志位亦然。页层级从叶层0计数至根层（树深-1）。（从叶向上计数确保分裂根时无需重编号现有页。）

Postgres磁盘块格式（项数组）不符合L&Y的键指针交替页概念，故需特殊处理。（内部分裂时键指针交替概念重要——分裂点位于枢轴元组中部：其"分隔键"作为左半新高键，指针/下行链接作为右半首下行链接。）

非层级最右页的首项为"高键"，真实数据项从第2项开始，高键的链接部分未使用。最右页无显式高键（隐式正无穷），数据项从首项开始。高键居左而非右看似反常，但避免添加数据项时移动高键。

叶页数据项为被索引表元组的TID链接及关联键值。

非叶页数据项为子页下行链接及边界键。每项的键为子页键严格下界（逻辑上位于下行链接左侧）。高键（如有）为末下行链接上界。每非叶页首数据项无下界（或视作负无穷），比较例程需相应处理。实际存储键值无关紧要甚至可不存。此布局对应L&Y非叶页"指针比键多一"的特性。后缀截断的负无穷属性同理。
